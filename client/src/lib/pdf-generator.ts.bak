import { PDFDocument, rgb, StandardFonts, PDFPage, PageSizes } from 'pdf-lib';
import { saveAs } from 'file-saver';
import { format } from 'date-fns';
import { WindDataHistorical, WindAlertThreshold } from '@shared/schema';
import { DeviceWithLatestData } from '@shared/types';

// Constants for PDF styling
const PAGE_WIDTH = 595.28; // A4 width in points
const PAGE_HEIGHT = 841.89; // A4 height in points
const MARGIN = 50; // Margin in points
const CONTENT_WIDTH = PAGE_WIDTH - (MARGIN * 2);
const PAGE_PADDING_TOP = 60; // Additional padding for page header
const LOGO_HEIGHT = 60; // Height for the logo

// Colors
const COLOR_BLACK = rgb(0, 0, 0);
const COLOR_WHITE = rgb(1, 1, 1);
const COLOR_GRAY = rgb(0.5, 0.5, 0.5);
const COLOR_LIGHT_GRAY = rgb(0.9, 0.9, 0.9);
const COLOR_BACKGROUND = rgb(0.98, 0.98, 0.98);
const COLOR_GREEN = rgb(0.13, 0.77, 0.37);
const COLOR_AMBER = rgb(0.96, 0.62, 0.04);
const COLOR_RED = rgb(0.94, 0.27, 0.27);
const COLOR_BLUE = rgb(0.23, 0.51, 0.97);

// Font sizes
const FONT_SIZE_TITLE = 22;
const FONT_SIZE_SUBTITLE = 16;
const FONT_SIZE_SECTION = 14;
const FONT_SIZE_NORMAL = 11;
const FONT_SIZE_SMALL = 9;

// Table settings
const TABLE_ROW_HEIGHT = 20;
const MAX_ROWS_PER_PAGE = 25; // Maximum number of data rows per page
const TABLE_HEADER_HEIGHT = 30;

interface ReportStats {
  maxWindSpeed: number;
  maxWindSpeedTime: Date | null;
  avgWindSpeed: number;
  totalDowntime: number;
  greenPercentage: number;
  amberPercentage: number;
  redPercentage: number;
}

/**
 * Generates a PDF report with wind data and statistics
 * Enhanced version with multi-page support, logo, and professional styling
 */
export async function generateWindReportPDF({
  device,
  windData,
  dateRange,
  stats,
  thresholds,
  reportGenTime
}: {
  device: DeviceWithLatestData;
  windData: WindDataHistorical[];
  dateRange: { from: Date | undefined; to: Date | undefined };
  stats: ReportStats;
  thresholds: WindAlertThreshold | undefined;
  reportGenTime: Date;
}) {
  try {
    // Create a new PDF document
    const pdfDoc = await PDFDocument.create();
    
    // Load fonts
    const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
    const timesRoman = await pdfDoc.embedFont(StandardFonts.TimesRoman);
    const timesRomanBold = await pdfDoc.embedFont(StandardFonts.TimesRomanBold);
    
    // Attempt to load and embed the logo
    let logoImage;
    try {
      // In a production environment, you would load from a public URL or file
      // For this example, we'll use fetch to get the logo from the public directory
      const response = await fetch('/height-tec-logo.png');
      const logoData = await response.arrayBuffer();
      logoImage = await pdfDoc.embedPng(new Uint8Array(logoData));
    } catch (error) {
      console.warn('Failed to load logo:', error);
      // We'll continue without the logo
    }
    
    // Create the first page
    const firstPage = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
    
    // Sort wind data chronologically
    const sortedWindData = [...windData].sort(
      (a, b) => new Date(a.intervalStart).getTime() - new Date(b.intervalStart).getTime()
    );
    
    // Calculate how many pages we'll need for the data table
    const totalPages = Math.ceil(sortedWindData.length / MAX_ROWS_PER_PAGE) + 1; // +1 for first page
    
    // Draw first page content (cover page with summary)
    await drawFirstPage(
      firstPage,
      logoImage,
      device,
      dateRange,
      thresholds,
      stats,
      reportGenTime,
      helveticaFont,
      helveticaBold,
      timesRomanBold,
      totalPages
    );
    
    // Draw data table pages
    await drawDataPages(
      pdfDoc,
      sortedWindData,
      device,
      dateRange,
      helveticaFont,
      helveticaBold,
      logoImage,
      reportGenTime,
      totalPages
    );
    
    // Serialize the PDF to bytes and download
    const pdfBytes = await pdfDoc.save();
    
    // Use file-saver to download the PDF
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const fileName = `wind-report-${device.deviceName}-${format(new Date(), 'yyyy-MM-dd')}.pdf`;
    saveAs(blob, fileName);
    
    return fileName;
  } catch (error) {
    console.error('Error generating PDF:', error);
    throw error;
  }
}

/**
 * Draws the first page with report header and summary statistics
 */
async function drawFirstPage(
  page: PDFPage,
  logoImage: any,
  device: DeviceWithLatestData,
  dateRange: { from: Date | undefined; to: Date | undefined },
  thresholds: WindAlertThreshold | undefined,
  stats: ReportStats,
  reportGenTime: Date,
  regularFont: any,
  boldFont: any,
  titleFont: any,
  totalPages: number
) {
  const { width, height } = page.getSize();
  
  // Draw page background
  page.drawRectangle({
    x: 0,
    y: 0,
    width,
    height,
    color: COLOR_WHITE,
  });
  
  // Draw header background
  page.drawRectangle({
    x: 0,
    y: height - 140,
    width,
    height: 140,
    color: COLOR_BACKGROUND,
  });
  
  // Draw logo if available
  if (logoImage) {
    const logoWidth = (logoImage.width / logoImage.height) * LOGO_HEIGHT;
    page.drawImage(logoImage, {
      x: MARGIN,
      y: height - MARGIN - LOGO_HEIGHT,
      width: logoWidth,
      height: LOGO_HEIGHT,
    });
  }
  
  // Title
  page.drawText('Wind Report', {
    x: width - MARGIN - 200,
    y: height - MARGIN - 30,
    size: FONT_SIZE_TITLE,
    font: titleFont,
    color: COLOR_BLACK,
  });
  
  // Report generation time
  page.drawText(`Generated: ${format(reportGenTime, 'PPpp')}`, {
    x: width - MARGIN - 200,
    y: height - MARGIN - 55,
    size: FONT_SIZE_NORMAL,
    font: regularFont,
    color: COLOR_GRAY,
  });
  
  // Page number
  page.drawText(`Page 1 of ${totalPages}`, {
    x: width - MARGIN - 70,
    y: MARGIN / 2,
    size: FONT_SIZE_SMALL,
    font: regularFont,
    color: COLOR_GRAY,
  });
  
  // Draw device info section
  const deviceInfoY = height - 180;
  
  // Draw section background
  page.drawRectangle({
    x: MARGIN,
    y: deviceInfoY - 120,
    width: CONTENT_WIDTH,
    height: 120,
    color: COLOR_WHITE,
    borderColor: COLOR_GRAY,
    borderWidth: 0.5,
    opacity: 0.9,
  });
  
  // Device name
  page.drawText(`Device: ${device.deviceName}`, {
    x: MARGIN + 20,
    y: deviceInfoY - 30,
    size: FONT_SIZE_SECTION,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Location
  if (device.location) {
    page.drawText(`Location: ${device.location}`, {
      x: MARGIN + 20,
      y: deviceInfoY - 55,
      size: FONT_SIZE_NORMAL,
      font: regularFont,
      color: COLOR_BLACK,
    });
  }
  
  // Date range
  if (dateRange.from && dateRange.to) {
    page.drawText(`Period: ${format(dateRange.from, 'PPP')} - ${format(dateRange.to, 'PPP')}`, {
      x: MARGIN + 20,
      y: deviceInfoY - 80,
      size: FONT_SIZE_NORMAL,
      font: regularFont,
      color: COLOR_BLACK,
    });
  }
  
  // Thresholds
  if (thresholds) {
    page.drawText(`Alert Thresholds:  Amber: ${thresholds.amberThreshold} km/h  |  Red: ${thresholds.redThreshold} km/h`, {
      x: MARGIN + 20,
      y: deviceInfoY - 105,
      size: FONT_SIZE_NORMAL,
      font: regularFont,
      color: COLOR_BLACK,
    });
    
    // Draw color indicators for thresholds
    page.drawRectangle({
      x: MARGIN + 150,
      y: deviceInfoY - 102,
      width: 10,
      height: 10,
      color: COLOR_AMBER,
    });
    
    page.drawRectangle({
      x: MARGIN + 280,
      y: deviceInfoY - 102,
      width: 10,
      height: 10,
      color: COLOR_RED,
    });
  }
  
  // Draw Summary Statistics Section
  const statsY = deviceInfoY - 150;
  
  // Draw section background with slight gradient effect
  page.drawRectangle({
    x: MARGIN,
    y: statsY - 220,
    width: CONTENT_WIDTH,
    height: 50,
    color: COLOR_BLUE,
    opacity: 0.1,
  });
  
  page.drawText('Summary Statistics', {
    x: MARGIN + 20,
    y: statsY - 30,
    size: FONT_SIZE_SUBTITLE,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Create a grid layout for statistics
  const colWidth = CONTENT_WIDTH / 2;
  
  // Maximum Wind Speed
  page.drawRectangle({
    x: MARGIN,
    y: statsY - 90,
    width: colWidth - 10,
    height: 50,
    color: COLOR_BACKGROUND,
    borderColor: COLOR_GRAY,
    borderWidth: 0.5,
  });
  
  page.drawText('Maximum Wind Speed', {
    x: MARGIN + 20,
    y: statsY - 55,
    size: FONT_SIZE_NORMAL,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  page.drawText(`${stats.maxWindSpeed.toFixed(1)} km/h`, {
    x: MARGIN + 20,
    y: statsY - 80,
    size: FONT_SIZE_SUBTITLE,
    font: boldFont,
    color: stats.maxWindSpeed > (thresholds?.redThreshold || 30) ? COLOR_RED : 
           stats.maxWindSpeed > (thresholds?.amberThreshold || 20) ? COLOR_AMBER : COLOR_BLACK,
  });
  
  if (stats.maxWindSpeedTime) {
    page.drawText(`Recorded at: ${format(stats.maxWindSpeedTime, 'PPp')}`, {
      x: MARGIN + 150,
      y: statsY - 80,
      size: FONT_SIZE_SMALL,
      font: regularFont,
      color: COLOR_GRAY,
    });
  }
  
  // Average Wind Speed
  page.drawRectangle({
    x: MARGIN + colWidth,
    y: statsY - 90,
    width: colWidth - 10,
    height: 50,
    color: COLOR_BACKGROUND,
    borderColor: COLOR_GRAY,
    borderWidth: 0.5,
  });
  
  page.drawText('Average Wind Speed', {
    x: MARGIN + colWidth + 20,
    y: statsY - 55,
    size: FONT_SIZE_NORMAL,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  page.drawText(`${stats.avgWindSpeed.toFixed(1)} km/h`, {
    x: MARGIN + colWidth + 20,
    y: statsY - 80,
    size: FONT_SIZE_SUBTITLE,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Total Downtime
  page.drawRectangle({
    x: MARGIN,
    y: statsY - 150,
    width: colWidth - 10,
    height: 50,
    color: COLOR_BACKGROUND,
    borderColor: COLOR_GRAY,
    borderWidth: 0.5,
  });
  
  page.drawText('Total Downtime', {
    x: MARGIN + 20,
    y: statsY - 115,
    size: FONT_SIZE_NORMAL,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Format downtime
  const downtimeHours = Math.floor(stats.totalDowntime / 3600);
  const downtimeMinutes = Math.floor((stats.totalDowntime % 3600) / 60);
  const downtimeFormatted = downtimeHours > 0 
    ? `${downtimeHours}h ${downtimeMinutes}m` 
    : `${downtimeMinutes}m`;
  
  page.drawText(downtimeFormatted, {
    x: MARGIN + 20,
    y: statsY - 140,
    size: FONT_SIZE_SUBTITLE,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Alert State Distribution
  page.drawRectangle({
    x: MARGIN + colWidth,
    y: statsY - 150,
    width: colWidth - 10,
    height: 50,
    color: COLOR_BACKGROUND,
    borderColor: COLOR_GRAY,
    borderWidth: 0.5,
  });
  
  page.drawText('Alert State Distribution', {
    x: MARGIN + colWidth + 20,
    y: statsY - 115,
    size: FONT_SIZE_NORMAL,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Draw mini bar graph for percentages
  const barWidth = (colWidth - 60) / 100; // Width per percentage point
  const barHeight = 12;
  const barY = statsY - 140;
  
  // Green portion
  page.drawRectangle({
    x: MARGIN + colWidth + 20,
    y: barY,
    width: barWidth * stats.greenPercentage,
    height: barHeight,
    color: COLOR_GREEN,
  });
  
  // Amber portion
  page.drawRectangle({
    x: MARGIN + colWidth + 20 + (barWidth * stats.greenPercentage),
    y: barY,
    width: barWidth * stats.amberPercentage,
    height: barHeight,
    color: COLOR_AMBER,
  });
  
  // Red portion
  page.drawRectangle({
    x: MARGIN + colWidth + 20 + (barWidth * (stats.greenPercentage + stats.amberPercentage)),
    y: barY,
    width: barWidth * stats.redPercentage,
    height: barHeight,
    color: COLOR_RED,
  });
  
  // Add percentage labels
  page.drawText(`${stats.greenPercentage.toFixed(1)}%`, {
    x: MARGIN + colWidth + 20,
    y: barY - 15,
    size: FONT_SIZE_SMALL,
    font: regularFont,
    color: COLOR_GREEN,
  });
  
  page.drawText(`${stats.amberPercentage.toFixed(1)}%`, {
    x: MARGIN + colWidth + 120,
    y: barY - 15,
    size: FONT_SIZE_SMALL,
    font: regularFont,
    color: COLOR_AMBER,
  });
  
  page.drawText(`${stats.redPercentage.toFixed(1)}%`, {
    x: MARGIN + colWidth + 220,
    y: barY - 15,
    size: FONT_SIZE_SMALL,
    font: regularFont,
    color: COLOR_RED,
  });
  
  // Legend
  page.drawRectangle({
    x: MARGIN,
    y: statsY - 190,
    width: CONTENT_WIDTH,
    height: 30,
    color: COLOR_BACKGROUND,
    borderColor: COLOR_GRAY,
    borderWidth: 0.5,
  });
  
  // Normal indicator
  page.drawRectangle({
    x: MARGIN + 20,
    y: statsY - 180,
    width: 10,
    height: 10,
    color: COLOR_GREEN,
  });
  
  page.drawText('Normal', {
    x: MARGIN + 40,
    y: statsY - 178,
    size: FONT_SIZE_SMALL,
    font: regularFont,
    color: COLOR_BLACK,
  });
  
  // Amber indicator
  page.drawRectangle({
    x: MARGIN + 120,
    y: statsY - 180,
    width: 10,
    height: 10,
    color: COLOR_AMBER,
  });
  
  page.drawText('Amber Alert', {
    x: MARGIN + 140,
    y: statsY - 178,
    size: FONT_SIZE_SMALL,
    font: regularFont,
    color: COLOR_BLACK,
  });
  
  // Red indicator
  page.drawRectangle({
    x: MARGIN + 240,
    y: statsY - 180,
    width: 10,
    height: 10,
    color: COLOR_RED,
  });
  
  page.drawText('Red Alert', {
    x: MARGIN + 260,
    y: statsY - 178,
    size: FONT_SIZE_SMALL,
    font: regularFont,
    color: COLOR_BLACK,
  });
  
  // Information about data table
  page.drawText('Wind Data Summary (Complete data available on following pages)', {
    x: MARGIN,
    y: statsY - 220,
    size: FONT_SIZE_NORMAL,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Footer
  drawFooter(page, 'Wind Monitor Professional Report');
}

/**
 * Draws the data table pages with wind data
 */
async function drawDataPages(
  pdfDoc: PDFDocument,
  sortedWindData: WindDataHistorical[],
  device: DeviceWithLatestData,
  dateRange: { from: Date | undefined; to: Date | undefined },
  regularFont: any,
  boldFont: any,
  logoImage: any,
  reportGenTime: Date,
  totalPages: number
) {
  // Skip if no data
  if (sortedWindData.length === 0) {
    return;
  }
  
  // Calculate number of pages needed for data
  const numPages = Math.ceil(sortedWindData.length / MAX_ROWS_PER_PAGE);
  
  for (let pageNum = 0; pageNum < numPages; pageNum++) {
    // Create a new page
    const page = pdfDoc.addPage([PAGE_WIDTH, PAGE_HEIGHT]);
    const { width, height } = page.getSize();
    
    // Draw page background
    page.drawRectangle({
      x: 0,
      y: 0,
      width,
      height,
      color: COLOR_WHITE,
    });
    
    // Draw header
    drawPageHeader(
      page, 
      logoImage,
      `Wind Data - ${device.deviceName}`,
      dateRange.from && dateRange.to 
        ? `Period: ${format(dateRange.from, 'PPP')} - ${format(dateRange.to, 'PPP')}`
        : '',
      boldFont,
      regularFont
    );
    
    // Draw page number
    page.drawText(`Page ${pageNum + 2} of ${totalPages}`, {
      x: width - MARGIN - 70,
      y: MARGIN / 2,
      size: FONT_SIZE_SMALL,
      font: regularFont,
      color: COLOR_GRAY,
    });
    
    // Get the slice of data for this page
    const startIdx = pageNum * MAX_ROWS_PER_PAGE;
    const endIdx = Math.min(startIdx + MAX_ROWS_PER_PAGE, sortedWindData.length);
    const pageData = sortedWindData.slice(startIdx, endIdx);
    
    // Draw table header
    const tableY = height - 120;
    
    // Table header background
    page.drawRectangle({
      x: MARGIN,
      y: tableY - TABLE_HEADER_HEIGHT,
      width: CONTENT_WIDTH,
      height: TABLE_HEADER_HEIGHT,
      color: COLOR_BLUE,
      opacity: 0.1,
    });
    
    // Draw column headers
    const colWidths = [100, 80, 100, 100, 70]; // Define column widths
    const headerY = tableY - 20;
    
    const columnLabels = ['Date', 'Time', 'Avg Wind', 'Max Wind', 'Alert'];
    let xPos = MARGIN + 20;
    
    columnLabels.forEach((label, idx) => {
      page.drawText(label, {
        x: xPos,
        y: headerY,
        size: FONT_SIZE_NORMAL,
        font: boldFont,
        color: COLOR_BLACK,
      });
      xPos += colWidths[idx];
    });
    
    // Draw table rows
    let rowY = tableY - TABLE_HEADER_HEIGHT;
    let rowIsOdd = false;
    
    for (const data of pageData) {
      // Alternating row background for better readability
      if (rowIsOdd) {
        page.drawRectangle({
          x: MARGIN,
          y: rowY - TABLE_ROW_HEIGHT,
          width: CONTENT_WIDTH,
          height: TABLE_ROW_HEIGHT,
          color: COLOR_LIGHT_GRAY,
          opacity: 0.3,
        });
      }
      rowIsOdd = !rowIsOdd;
      
      // Determine row color based on alert state
      let rowColor = COLOR_BLACK;
      if (data.redAlertTriggered) {
        rowColor = COLOR_RED;
      } else if (data.amberAlertTriggered) {
        rowColor = COLOR_AMBER;
      }
      
      const startTime = new Date(data.intervalStart);
      xPos = MARGIN + 20;
      
      // Draw cell contents
      page.drawText(format(startTime, 'yyyy-MM-dd'), {
        x: xPos,
        y: rowY - 15,
        size: FONT_SIZE_SMALL,
        font: regularFont,
        color: rowColor,
      });
      xPos += colWidths[0];
      
      page.drawText(format(startTime, 'HH:mm'), {
        x: xPos,
        y: rowY - 15,
        size: FONT_SIZE_SMALL,
        font: regularFont,
        color: rowColor,
      });
      xPos += colWidths[1];
      
      page.drawText(`${data.avgWindSpeed.toFixed(1)} km/h`, {
        x: xPos,
        y: rowY - 15,
        size: FONT_SIZE_SMALL,
        font: regularFont,
        color: rowColor,
      });
      xPos += colWidths[2];
      
      page.drawText(`${data.maxWindSpeed.toFixed(1)} km/h`, {
        x: xPos,
        y: rowY - 15,
        size: FONT_SIZE_SMALL,
        font: regularFont,
        color: rowColor,
      });
      xPos += colWidths[3];
      
      const alertText = data.redAlertTriggered 
        ? 'Red' 
        : data.amberAlertTriggered 
          ? 'Amber' 
          : 'Normal';
      
      page.drawText(alertText, {
        x: xPos,
        y: rowY - 15,
        size: FONT_SIZE_SMALL,
        font: regularFont,
        color: rowColor,
      });
      
      // Move to next row
      rowY -= TABLE_ROW_HEIGHT;
    }
    
    // Draw footer
    drawFooter(page, 'Data displayed in chronological order');
  }
}

/**
 * Draws the page header with logo and title
 */
function drawPageHeader(
  page: PDFPage,
  logoImage: any, 
  title: string,
  subtitle: string,
  boldFont: any,
  regularFont: any
) {
  const { width, height } = page.getSize();
  
  // Draw header background
  page.drawRectangle({
    x: 0,
    y: height - 80,
    width,
    height: 80,
    color: COLOR_BACKGROUND,
  });
  
  // Draw logo if available
  if (logoImage) {
    const logoHeight = 40;
    const logoWidth = (logoImage.width / logoImage.height) * logoHeight;
    page.drawImage(logoImage, {
      x: MARGIN,
      y: height - MARGIN - logoHeight,
      width: logoWidth,
      height: logoHeight,
    });
  }
  
  // Draw title
  page.drawText(title, {
    x: width - MARGIN - 300,
    y: height - MARGIN - 20,
    size: FONT_SIZE_SECTION,
    font: boldFont,
    color: COLOR_BLACK,
  });
  
  // Draw subtitle if provided
  if (subtitle) {
    page.drawText(subtitle, {
      x: width - MARGIN - 300,
      y: height - MARGIN - 40,
      size: FONT_SIZE_NORMAL,
      font: regularFont,
      color: COLOR_GRAY,
    });
  }
  
  // Draw separator line
  page.drawLine({
    start: { x: MARGIN, y: height - 80 },
    end: { x: width - MARGIN, y: height - 80 },
    thickness: 1,
    color: COLOR_GRAY,
    opacity: 0.5,
  });
}

/**
 * Draws the page footer
 */
function drawFooter(page: PDFPage, text: string) {
  const { width, height } = page.getSize();
  
  // Draw separator line
  page.drawLine({
    start: { x: MARGIN, y: MARGIN },
    end: { x: width - MARGIN, y: MARGIN },
    thickness: 1,
    color: COLOR_GRAY,
    opacity: 0.3,
  });
  
  // Draw footer text
  page.drawText(text, {
    x: MARGIN,
    y: MARGIN / 2,
    size: FONT_SIZE_SMALL,
    color: COLOR_GRAY,
  });
}